#!/bin/bash
set -euo pipefail

# EC2 user-data to provision a single host running SFTP, WireGuard, and personal-site via Docker Compose.
# - Installs Docker and compose plugin
# - Mounts EFS at ${efs_mount_path} for persistent storage
# - Copies SFTP container build context
# - Renders docker-compose.yml from provided template and starts the stack

AWS_REGION=${aws_region}
ENVIRONMENT=${environment}
PROJECT_NAME=${project_name}
EFS_FS_ID=${efs_file_system_id}
EFS_MOUNT=${efs_mount_path}
DOCKER_COMPOSE_YML=$(cat <<'YAML'
${docker_compose_yml}
YAML
)

export DNF_YUM=1
dnf -y update || true
dnf -y install docker || true

# Ensure any old/incorrect compose plugin path is not shadowing
rm -f /usr/lib/docker/cli-plugins/docker-compose || true

# Start Docker using systemctl (preferred), with fallbacks
if command -v systemctl >/dev/null 2>&1; then
  systemctl enable docker || true
  systemctl start docker || true
  if ! systemctl is-active --quiet docker; then
    service docker start || true
  fi
else
  service docker start || true
fi

# Wait for Docker daemon readiness
for i in {1..20}; do
  docker info >/dev/null 2>&1 && break || sleep 3
done

groupadd -f docker || true
id "ec2-user" >/dev/null 2>&1 && usermod -aG docker "ec2-user" || true

mkdir -p /opt/docker-app/{config,secrets,logs,sftp}
cd /opt/docker-app

# Mount EFS for persistence
mkdir -p "$EFS_MOUNT"
if ! grep -q "$EFS_MOUNT" /etc/fstab; then
  echo "$EFS_FS_ID.efs.$AWS_REGION.amazonaws.com:/ $EFS_MOUNT nfs4 defaults,_netdev 0 0" >> /etc/fstab
fi
mount -a || true

# Prepare EFS subdirs and permissions
mkdir -p "$EFS_MOUNT/sftp" "$EFS_MOUNT/wireguard" "$EFS_MOUNT/postgres"
chown -R 1000:1000 "$EFS_MOUNT/sftp" "$EFS_MOUNT/wireguard" || true
chmod 750 "$EFS_MOUNT/sftp" "$EFS_MOUNT/wireguard" || true

# Prepare CoreDNS configuration (Route53 private zone + optional DNS-over-TLS forwarders)
mkdir -p /opt/docker-app/config/coredns

# Generate CoreDNS configuration
{
  echo "# Autogenerated CoreDNS configuration"
  if [ -n "${route53_zone_id}" ] && [ -n "${domain_name}" ]; then
    echo "${domain_name} {"
    echo "  route53 ${domain_name}.:${route53_zone_id} {"
    echo "    upstream"
    echo "    fallthrough"
    echo "  }"
    echo "  cache 30"
    echo "  errors"
    echo "}"
    echo
  fi
  echo ". {"
  echo "  hosts /etc/coredns/hosts {"
  echo "    fallthrough"
  echo "  }"
  echo "  forward . ${dns_servers} {"
  echo "    tls_servername ${dns_tls_servername}"
  echo "  }"
  echo "  cache 30"
  echo "  errors"
  echo "}"
} > /opt/docker-app/config/coredns/Corefile

cat > /opt/docker-app/config/coredns/hosts <<EOF
172.20.0.53 coredns
EOF

# Copy SFTP container build context
cat > /opt/docker-app/sftp/Dockerfile <<'DOCKERFILE'
FROM alpine:3.22

RUN apk add --no-cache openssh-server && \
    mkdir -p /var/run/sshd /data && \
    ssh-keygen -A

COPY sshd_config /etc/ssh/sshd_config
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

EXPOSE 22
ENTRYPOINT ["/entrypoint.sh"]
DOCKERFILE

cat > /opt/docker-app/sftp/sshd_config <<'SSHDCONFIG'
Port 22
AddressFamily any
ListenAddress 0.0.0.0

# Security settings
PermitRootLogin no
PasswordAuthentication no
PermitEmptyPasswords no
ChallengeResponseAuthentication no
KbdInteractiveAuthentication no
UsePAM no

# Public key authentication
PubkeyAuthentication yes
AuthorizedKeysFile /etc/ssh/authorized_keys/%u

# SFTP subsystem
Subsystem sftp internal-sftp

# Restrict sftp-sync-user to SFTP only
Match User sftp-sync-user
    ChrootDirectory /data
    ForceCommand internal-sftp
    AllowTcpForwarding no
    X11Forwarding no
    PermitTunnel no
    AllowAgentForwarding no
SSHDCONFIG

cat > /opt/docker-app/sftp/entrypoint.sh <<'ENTRYPOINT'
#!/bin/sh
set -e

# Create user if not exists
if ! id sftp-sync-user >/dev/null 2>&1; then
    adduser -D -u 1000 -h /home/sftp-sync-user -s /sbin/nologin sftp-sync-user
fi

# Set up authorized keys directory and file
mkdir -p /etc/ssh/authorized_keys
echo "$SFTP_PUBLIC_KEY" > /etc/ssh/authorized_keys/sftp-sync-user
chmod 644 /etc/ssh/authorized_keys/sftp-sync-user

# Chroot requires root ownership of /data, user writes to subdirectory
chown root:root /data
chmod 755 /data

# Create upload directory owned by user
mkdir -p /data/files
chown sftp-sync-user:sftp-sync-user /data/files
chmod 750 /data/files

# Start sshd in foreground
exec /usr/sbin/sshd -D -e
ENTRYPOINT

chmod +x /opt/docker-app/sftp/entrypoint.sh

# Enable IPv4 forwarding on host (defense in depth for WireGuard NAT)
sysctl -w net.ipv4.ip_forward=1 || true
if ! grep -q "^net.ipv4.ip_forward" /etc/sysctl.conf; then
  echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf
fi

# Write docker-compose.yml from injected template
echo "$DOCKER_COMPOSE_YML" > docker-compose.yml

# Authenticate with ECR for private image access
if command -v aws >/dev/null 2>&1; then
  echo "Authenticating with ECR..."
  aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "${ecr_registry_url}" && echo "ECR authentication successful" || echo "WARNING: ECR authentication failed"
else
  echo "WARNING: AWS CLI not found; skipping ECR authentication"
fi

# Ensure Docker Compose v2 plugin is available (install to /usr/libexec if needed)
if ! docker compose version >/dev/null 2>&1; then
  mkdir -p /usr/libexec/docker/cli-plugins
  ARCH=$(uname -m)
  case "$ARCH" in
    aarch64)
      COMPOSE_URL="https://github.com/docker/compose/releases/download/v2.39.4/docker-compose-linux-aarch64" ;;
    *)
      COMPOSE_URL="" ;;
  esac
  if [ -n "$COMPOSE_URL" ]; then
    curl -fsSL -o /usr/libexec/docker/cli-plugins/docker-compose "$COMPOSE_URL" || \
    wget -q -O /usr/libexec/docker/cli-plugins/docker-compose "$COMPOSE_URL" || true
    chmod +x /usr/libexec/docker/cli-plugins/docker-compose || true
  fi
fi

# Start the stack (only if compose plugin is available)
if docker compose version >/dev/null 2>&1; then
  docker compose up -d --build
else
  echo "WARNING: docker compose plugin not available; skipping stack start" >&2
fi

exit 0
